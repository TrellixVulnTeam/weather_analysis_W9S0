import csv
import os
from concurrent.futures import ThreadPoolExecutor
from contextlib import contextmanager
from typing import Dict, Tuple
from zipfile import ZipFile

import argparse
import numpy as np
import pandas as pd
from geopy import Here
# from geopy.adapters import AioHTTPAdapter
# from geopy.geocoders import Nominatim

import app.treat #import save_hist_graphics


class Data:
    centres = []
    threads = 50
    path_inp = 'D:\\weather_analysis\\test\\test_dir\\'
    path_out = 'D:\\weather_analysis\\test\\test_dir\\'
    api_key_forecast = "653e3ab3208c8cb799cce402dd5d7580"
    api_key_geoloc = 'zMvc4lJQRalNBC7yf3x2lXqlwTCM93jLCaCK4nm89cU'


@contextmanager
def unpack_files(path):
    source_dir = os.listdir(path)
    list_open_files = unpack_zip(source_dir, path)
    try:
        yield
    finally:
        for file in list_open_files:
            try:
                os.remove(path + file)
            finally:
                continue


def unpack_zip(source_list, path):
    for file in source_list:
        if file.endswith(".zip"):
            with ZipFile(path + file) as myzip:
                myzip.extractall(path)
                return myzip.namelist()


def readline_gen(path_input):
    source_dir = os.listdir(path_input)
    for file in source_dir:
        if file.endswith(".csv"):
            with open(path_input + file) as f:
                reader = csv.reader(f)
                for line in reader:
                    yield line


def coord_validator(coords):
    latitude = coords[0]
    longitude = coords[1]
    try:
        latitude = float(latitude)
        longitude = float(longitude)
    except ValueError:
        return False
    return -90 <= latitude <= 90 and -180 <= longitude <= 180


# def args_parser():
#     parser = argparse.ArgumentParser(description='Weather analysis.')
#     parser.add_argument('path_input', type=Path,
#                         help='path to directory with input data')
#     parser.add_argument('path_output', type=Path,
#                         help='path to the directory for the output')
#     parser.add_argument('threads', type=int,
#                         help='number of threads for parallel data processing')
#     args = parser.parse_args()
#     os.chdir(args.path_input)
#     return args.path_input, args.path_output, args.threads


def get_correct_df(path):
    with unpack_files(path):
        df = pd.DataFrame(columns=('Name', 'Country', 'City', 'Latitude', 'Longitude'))
        for num, line in enumerate(readline_gen(path)):
            val = coord_validator((line[4], line[5]))
            if line[1] and line[2] and line[3] and val:
                df.loc[num] = line[1:]
        return df


def get_address(latitude, longitude):
    pass
    # geolocator = Here(apikey=Data.api_key_geoloc) #, adapter_factory=AioHTTPAdapter
    # coord_str = str(latitude)+", "+str(longitude)
    # return str(geolocator.reverse(coord_str))


def get_list_addresses(df2):
    lat = df2.Latitude.tolist()
    long = df2.Longitude.tolist()
    with ThreadPoolExecutor(max_workers=Data.threads) as pool:
        responses = pool.map(get_address, *(lat, long))
    return list(responses)


def get_cities_centre(df2):
    df_sort = df2.sort_values("City").reset_index(drop=True)
    hotels_1_city = []
    curr_city = (df_sort.loc[0].Country, df_sort.loc[0].City)
    try:
        for i in df_sort.loc:
            if curr_city == (i.Country, i.City):
                hotels_1_city.append((i.Latitude, i.Longitude))
            else:
                find_center = np.array(hotels_1_city).astype(float).mean(axis=0).tolist()
                Data.centres.append([curr_city, find_center])
                curr_city = (i.Country, i.City)
                hotels_1_city = [(i.Latitude, i.Longitude)]
    except KeyError:
        find_center = np.array(hotels_1_city).astype(float).mean(axis=0).tolist()
        Data.centres.append([curr_city, find_center])
    return Data.centres


def select_main_cities(df):
    df1 = df.groupby(by=["Country", "City"], as_index=False).agg({"Name": "count"})
    df1 = df1.sort_values(["Name"], ascending=False).groupby("Country").head(1)
    # df1.columns = ["Country", "City", "Name"]
    print(df1)
    # print(df)
    # print(df1.City, df1.Country)
    df2 = df.loc[df.City.isin(df1.City) & df.Country.isin(df1.Country)].reset_index(drop=True)
    return df2.copy()


def add_geo_address(df2):
    df2.loc[:, "Geo_address"] = get_list_addresses(df2) #df2.apply(lambda x: get_address(x["Latitude"], x["Longitude"]), axis=1)
    df2 = df2[["Name", "Geo_address", "Country", "City", "Latitude", "Longitude"]]
    return get_cities_centre(df2)


if __name__ == "__main__":
    # args = args_parser()
    path_input = Data.path_inp
    threads = Data.threads
    path_output = Data.path_out
    centres = add_geo_address(select_main_cities(get_correct_df(path_input)))
    print(len(centres))
    print(centres)
    app.treat.save_hist_graphics(centres)
